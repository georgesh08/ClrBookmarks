## Принцип работы оператора _new_

1. Вычисляет число байтов, необходимых всем экземплярным полям типа и всем его базовым типам, включая System.Object (в нем отсутствуют собственные экземплярные поля) + каждый объект кучи требует дополнительных членов: _указатель на объект-тип(type object pointer)_ и _индекс блока синхронизации(sync block index)_. Эти дополнительные члены служат CLR для управления объектом. Байты доп. членов добавляются к байтам, необходимым для размещения самого объекта.

2. new выделяет память для объекта, резервируя необходимое число байтов в управляемой куче байтов, а затем устанавливает все байты в ноль.

3. Инициализируется указатель на объект-тип и индекс блока синхронизации.

4. Вызывается конструктор экземпляра типа с параметрами, указанными при вызове new. Компилятор автоматически создает в конструкторе код вызова конструктора базового класса. Каждый конструктор выполняет инициализацию определенных в соответствующем типе полейю В частности, вызывается конструктор System.Object, но он ничего не делает и просто возвращает управление.

Выполнив все операции, new возвращает ссылку на созданный объект.

## Приведение типов

Точно определеить тип объекта позволяет метод GetType(). Поскольку он невиртуальный, никакой тип не сможет его переопределить и сообщить ложные сведения о себе.

CLR разрешает привести тип объекта к его собственному типу или любому из его базовых типов. В C# нет специального синтаксиса для приведения типа объекта к его базовому типу, такое приведение считается безопасным неявным преобразованием. Однако для приведения типа к производному от него типу должна вводится операция явного приведения типов - неявное преобразование приведет к ошибке.

## Приведение типов в C# с помощью операторов  is и as

Оператор is проверяет совметсимость объекта с данным типом, а в качестве результата выдает значения true или false.

Контроль типов в CLR укрепляет безопасность, но при этом приходится жертвовать производительностью, т.к. среда должна выяснять фактический тип объекта, на который ссылается переменная, а затем проверять всю иерархию наследования на предмет наличия среди базовых типов заданного типа.

```c#
Employee e = o as Employee // o of Object type

if (e != null) {
    // some logic
}
```

В данном примере CLR проверяет совместимость o с типом Employee, если это так, as возвращает ненулевой указатель на этот объект, иначе вернется null.

Оператор as отличается от оператора приведения типа тем, что никогда не генерирует исключение, а только взвращает null, если приведение не возможно.

## Как разные компоненты взаимодействуют во время выполнения

Представим пример работы одного процесса. У процесса может быть много потоков. После создания потоку выделяется стек размером 1 МБ. Выделенная для стека память используется дял передачи параметров в методы и хранения определенных в пределах методов локальных переменных.

Все методы, кроме самых простых содержат некоторый входной код (_prologue code_), инициализирующий метод до начала его работы. Кроме того, эти методы содержат выходной код (_epilogue code_), выполняющий очистку после того, как метод завершит своб основную работу, чтобы возвратить управление вызывающей программе.

Для примера возьмем методы:

```c#
void M1() {
    String name = "George"
    M2(name);
    // some logic
    return;
}

void M2(String name) {
    int length = s.Length;
    int tally;
    // some logic
    return;
}
```

В начале выполнения метода M1 его входной код выделит память под локальную переменную name. Далее M1 вызывает метод M2б передавая в качестве аргумента локальную переменную name(память для нее так жу будет выделена на стеке в переменной-параметре s). При вызове метода адрес возврата и вызывающий метод так же попадают на стек.

В начале выполнения M2 его входной код выделяет память на стеке под перменные lenght и tally. Когда выполнение M2 дойдет до команды возврата, она запишет в указатель команд процессора возврата адрес возврата из стека и стековый фрейм вернется в состояние, которые было до вызова метода M2. Аналогичное произойдет и с методом M1 - он вернет управление вызывающей программе, устанавливая указатель команд процессора на адрес возврата (будет находится сразу перед переменной name на стеке).

Посмотрим на пример работы в CLR:
```C#
internal class Employee()
{
    public int GetYearsEmployed() { ... }
    public virtual String GetProgressReport () { ... }
    public static Employee Lookup(String name) { ... }
}

internal sealed class Manager : Employee 
{
    public override String GetProcessReport() { ... }
}

void M3() 
{
    Employee e;
    int year;
    e = new Manager();
    e = Employee.Lookup("George")
    year = e.GetYearEmployed();
    e.GetProgressReport();
}
```

В процессе преобразования IL-кода метода М3 в машинные команды JIT-компилятор выявляет все типы, на которые есть ссылки в М3, - это типы Employee, int, Managar и String. CLR получает информацию о типах на основе метаданных из сборок, в которые входят эти типы, и создает структуры данных, представляющие эти типы.

У объектов типа Employee и Manager есть два дополнительных члена: указатель на объект-тип и индекс блока синхронизации. Определяя тип, можно создать в нем статические поля данных. Байты для этих статических полей выделяются в составе самих объектов-типов. У каждого объекта-типа есть таблица методов с входными точками всех методов, определенных в типе.  Соттветственно в таблице методов типа Manager одна запись, в Employee - три.

При выполнении входного кода М3 в стеке потока выделяется память для локальных переменных. CLR автоматически инициализирует все локальные переменные значением null или 0. Компилятор C# генерирует сообщение об ошибке _Use of assigned local variable_ в случае, если вы попытаетесь обратиться к неявно инициализированной локальной переменной. 

Всякий раз при создании нового объекта в куче CLR автоматиечски инициализируется внутренний член-указатель на объект-тип так, чтобы он указывал на соответствующий объект-тип объекта.

Рассмотрим вызов статического метода Lookup. При вызове метода CLR определяет местонахождение объекта-типа, соответствующего типу, в котором определен статический метод. Затем в таблице методов объекта-типа находит точку входа в метод, обрабатывает код JIT-компилятором(при необходимости) и вызывает полученный машинный код. Допустим метод вернет намм объект типа Manager, поэтому в куче будет создан новый объект соответствующего типа и вернется адрес готового объекта.

Поскольку e больше не ссылается на первый созданный объект Manager и нет переменных, которое на него ссылаются, на сследующем проходе сборщика мусора память, выделенная под этот объект будет особождена.

Далее вызывается метод GetYearsEmployed объекта Employee. При этом CLR определяет местонахождение объекта типа, соответствующего типу переменной. Если бы вызываемый метод не был определен в типе Employee, в процессе поиска метода среда CLR начала бы последовательно просматривать классы иерархии - вплость до Object).

При вызове виртуального экземплярног метода CLR приходится выполнять некоторую дополнительную работу. Во-первых, CLR обращается к переменной, используемой для вызова, и затем следует по адресу вызывающего объекта. В данном случае переменная е указывает на объект типа Manager. Во-вторых, CLR проверяет у объекта внутренний член-указатель на объект-тип; этот член ссылается на фактический тип объекта.

Затем CLR находит в таблице методов объекта-тип запись о входе в вызываемый метод, обрабатывается код JIT-компилятором и вызывает полученный машинный код.

Объекты-типы - это, по сути, и есть сами объекты. Создавая объекты-типы, среда CLR должна их инициализировать. При своем запуске в процессе CLR сразу же создает специальный объект-тип для типа _System.Type_. Объекты типа Employee и Manager являются "экземплярами" этого типа, и по этой причине их указаатели на объекты-типы инициализируются так, чтобы ссылаться на объект-тип _System.Type_.

Конечно, объект-тип _System.Type_ сам является объектом и поэтому так же имеет член-указатель на объект-тип. Ссылается он на самого себя, т.к. объект-тип _System.Type_ сам по себе является "экземпляром" объекта-типа. 